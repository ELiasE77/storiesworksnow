package com.digitallife.journal_site.Journal;

import com.digitallife.journal_site.communities.Community;
import com.digitallife.journal_site.communities.CommunityRepository;
import com.digitallife.journal_site.exceptions.ResourceNotFoundException;
import com.digitallife.journal_site.user.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * used to interact with the journal entries database
 */
@Service
public class JournalService {

    @Autowired
    private JournalEntryRepository journalEntryRepository;

    @Autowired
    private CommunityRepository communityRepository;

    /**
     * saves a journal entry to the database
     *
     * @param user the user which wrote the journal entry
     * @param title the title of the new entry
     * @param content the content of the new entry
     * @param imageUrl the Base64 String of the image
     * @param communityId the possible community it belongs to
     * @param visibility the visibility selected for this entry (Public, Private or Community)
     */
    public void saveJournalEntry(User user, String title, String content, String imageUrl, Long communityId, JournalEntry.Visibility visibility) {
        JournalEntry journalEntry = new JournalEntry();

        if (title != null && !title.isEmpty()) {
            journalEntry.setTitle(title);
        }


        if (visibility == JournalEntry.Visibility.COMMUNITY && communityId != null) {
            Community community = communityRepository.findById(communityId)
                    .orElseThrow(() -> new RuntimeException("Community not found"));
            journalEntry.setCommunity(community);
        }

        journalEntry.setVisibility(visibility);
        journalEntry.setUser(user);
        journalEntry.setContent(content);
        journalEntry.setTimestamp(LocalDateTime.now());

        if (imageUrl != null) {
            journalEntry.setImage(imageUrl);
        }
        journalEntryRepository.save(journalEntry);
    }

    /**
     * used to update an existing journal in the database, uses the setters of the journalEntry class
     *
     * @param id the id of the journal entry in the database (is auto generated by mySql database)
     * @param title the new title of the journal entry
     * @param content the new content of the journal entry
     * @param imageUrl the new base64 String image
     * @param visibility the new visibility (Private, public or community)
     * @param communityId the possible communityId in which it was posted
     */
    public void updateJournalEntry(Long id, String title, String content, String imageUrl, JournalEntry.Visibility visibility, Long communityId) {
        JournalEntry entry = journalEntryRepository.findById(id).orElseThrow(() -> new RuntimeException("Entry not found"));
        entry.setTitle(title);
        entry.setContent(content);
        entry.setImage(imageUrl);
        entry.setVisibility(visibility);

        //if the visibility is set to community also update the community to which it was uploaded (if a community was selected)
        if (visibility == JournalEntry.Visibility.COMMUNITY && communityId != null) {
            Community community = communityRepository.findById(communityId)
                    .orElseThrow(() -> new RuntimeException("Community not found"));
            entry.setCommunity(community);
        }

        //save the new entry
        journalEntryRepository.save(entry);
    }

    /**
     * used to get all the entries for this specific user
     *
     * @param user the user from which we want the entries
     * @return a list of all journal entries of this user
     */
    public List<JournalEntry> getEntriesByUser(User user) {
        return journalEntryRepository.findByUser(user);
    }

    /**
     * find the journal entries based on the id provided (used to find the journal entry needed for the journal editing page)
     *
     * @param id id of the journal entry which needs to be found
     * @return the journalEntry belonging to that id
     * @throws ResourceNotFoundException if a journalEntry was not found with that id
     */
    public JournalEntry findJournalEntryById(Long id) throws ResourceNotFoundException {
        return journalEntryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Journal entry not found with id: " + id));
    }

    /**
     * finds all entries sorted on their time of entry (newest first)
     * @return list of all entries sorted
     */
    public List<JournalEntry> findAllEntriesSortedByTimestamp() {
        return journalEntryRepository.findAllByOrderByTimestampDesc();
    }

    /**
     * find journal entries based on the current month and year
     * @param user the user which we need to find the entries of
     * @return list of all journalentries
     */
    public List<Object[]> findMonthAndYear(User user) {
        return journalEntryRepository.findDistinctMonthsAndYearsWithImages(user);
    }

    /**
     * find all entries of a user based on the month and year provided by the user
     *
     * @param user the user we need to find the entries of
     * @param month the month provided by the user of which he would like to know the entries
     * @param year the year provided by the user of which he would like to know the entries
     * @return list of entries based on previous specifications
     */
    public List<JournalEntry> findEntriesForMonthAndYear(User user, Integer month, Integer year) {
        return journalEntryRepository.findByUserAndMonthAndYearWithImages(user, month, year);
    }

    public List<JournalEntry> findCommunityEntries(Community community) {
        return journalEntryRepository.findByCommunityOrderByTimestampDesc(community);
    }

    public void deleteJournalEntry(Long id) {
        Optional<JournalEntry> journalEntryOptional = journalEntryRepository.findById(id);
        if (journalEntryOptional.isEmpty()) {
            return;
        }
        journalEntryRepository.deleteById(id);
    }

    /**
     * finds all entries with visibility set to public
     *
     * @return list of all entries set to public
     */
    public List<JournalEntry> findPublicEntriesSortedByTimestamp() {
        return journalEntryRepository.findByVisibilityOrderByTimestampDesc(JournalEntry.Visibility.PUBLIC);
    }

}


